{
  "name": "thunks",
  "description": "A basic asynchronous utilily module beyond Promise magically.",
  "authors": [
    "Yan Qing <admin@zensh.com>"
  ],
  "version": "1.5.3",
  "main": "thunks.js",
  "repository": {
    "type": "git",
    "url": "git@github.com:thunks/thunks.git"
  },
  "homepage": "https://github.com/thunks/thunks",
  "keywords": [
    "async",
    "thunk",
    "thunks",
    "Promise",
    "flow"
  ],
  "dependencies": {},
  "devDependencies": {
    "gulp": "^3.5.6",
    "gulp-jshint": "^1.8.4",
    "gulp-mocha": "^1.0.0",
    "gulp-rename": "^1.2.0",
    "gulp-uglify": "^0.3.1",
    "gulp-sequence": "^0.1.0",
    "jsbench": ">=0.3.x",
    "mocha": "^1.21.0",
    "should": "^4.0.4",
    "thenjs": ">=1.4.0"
  },
  "scripts": {
    "test": "gulp test"
  },
  "ignore": [
    "**/.*",
    "node_modules",
    "benchmark",
    "test",
    "examples",
    "gulpfile.js"
  ],
  "readme": "thunks v1.5.3 [![Build Status](https://travis-ci.org/thunks/thunks.svg)](https://travis-ci.org/thunks/thunks)\n====\nA basic asynchronous utilily module beyond Promise magically.\n\n[中文说明](https://github.com/thunks/thunks/blob/master/README_zh.md)\n\nThinking and programming in thunks is similar to that in native Promise. But there are some different points:\n\n1. Native Promise is a new feature in ES6, thunks is not using JavaScript special features to run flawlessly under ES3.\n\n2. After wrapped by Promise we get objects with logics in Promise objects,\nmethods of properties of these Promise objects could be modified(injuected);\nWhile thunks returns thunk functions, with logics inside function scopes,\nwhich means they would never be injected from outside.\n\n3. Promise claims it's functional, while thunks is functional\nand it obeys the continuous-passing style.\n\n4. Having the same power as Promise, thunks' API is more consice,\nand thunks' implementaton is simpler.\n\n5. thunks brings a perfect `debug` mode, which seems not appear in Promise?\n\n6. thunks is **5 times** faster as native Promise.\n\nRead in `exmples/` diretory for more demos on thunks.\nBuild asynchronous program in an extraordinary simple way.\n\n**You don't have to wait till all bowsers have implemented Promise natively, but by just these **200sloc** you will get more powerful tools for handling aynchronous code.**\n\n## What is a thunk?\n\n1. **`thunk`** is a function that encapsulates synchronous or asynchronous code inside.\n\n2. **`thunk`** accepts only one `callback` function as an arguments, which is a CPS function;\n\n3. **`thunk`** returns another **`thunk`** function after being called, for chaining operations;\n\n4. **`thunk`** would passing the results into a `callback` function after excuted.\n\n5. If `callback` returns a new **`thunk`** function, then it would be send to another **`thunk`** to excute,\nor it would be send to another new **`thunk`** function as the value of the computation.\n\n## Benchmark\n\nBy running `node benchmark/index.js` in a CentOS virtual machine:\n\n```bash\n[root@centos thunk]# node benchmark/index\nSync Benchmark...\n\nJSBench Start (100 cycles, async mode):\nTest Promise...\nTest thunk...\n\nJSBench Results:\nPromise: 1000 cycles, 13.238 ms/cycle, 75.540 ops/sec\nthunk: 1000 cycles, 2.463 ms/cycle, 406.009 ops/sec\n\nPromise: 100%; thunk: 537.47%;\n\nJSBench Completed!\n```\n\n**By testing with the same operations, Thunk performs 4 times faster comparing to native Promise.**\n\n## Demo\n\n```js\nvar thunks = require('../thunks.js');\nvar fs = require('fs');\nvar Thunk = thunks(function (error) { console.error('Thunk error:', error); });\n\nThunk.\n  all(['examples/demo.js', 'thunks.js', '.gitignore'].map(function (path) {\n    return Thunk(function (callback) { fs.stat(path, callback); });\n  }))(function (error, result) {\n    console.log('Success: ', result);\n    return Thunk(function (callback) { fs.stat('none.js', callback); });\n  })(function (error, result) {\n    console.error('This should not run!', error);\n  });\n```\n\nNo `Maximum call stack size exceeded` error in 1000000 sync series\n\n```js\nvar Thunk = require('../thunks.js')();\nvar thunk = Thunk(0);\n\nfunction callback(error, value) {\n  return ++value;\n}\n\nconsole.time('Thunk_series');\nfor (var i = 0; i < 1000000; i++) {\n  thunk = thunk(callback);\n}\n\nthunk(function (error, value) {\n  console.log(error, value); // null 1000000\n  console.timeEnd('Thunk_series'); // ~827ms\n});\n```\n\n## Installation\n\n**Node.js:**\n\n    npm install thunks\n\n**Bower:**\n\n    bower install thunks\n\n**browser:**\n\n```html\n<script src=\"/pathTo/thunks.js\"></script>\n```\n\n## API\n\n```js\nvar thunks = require('thunks');\n```\n\n### thunks([options])\n\nGenerator of `thunks`, it generates the main function of `Thunk` with its scope.\n\"scope\" refers to the running evironments `Thunk` generated(directly or indirectly) for all `thunk` functions.\n\n1. Here's how you create a basic `Thunk`, any exceptions would be passed the next `thunk` function:\n\n    ```js\n    var Thunk = thunks();\n    ```\n\n2. Here's the way to create a `Thunk` listening to all exceptions in current scope with `onerror`,\nand it will make sure the exeptions not being passed to the followed `thunk` function, unless `onerror` function return `true`.\n\n    ```js\n    var Thunk = thunks(function (error) { console.error(error); });\n    ```\n\n3. Create a `Thunk` with `onerror` and `debug` listeners.\nResults of this `Thunk` would be passed to `debug` function first before passing to the followed `thunk` function.\n\n    ```js\n    var Thunk = thunks({\n      onerror: function (error) { console.error(error); },\n      debug: function () { console.log.apply(console, arguments); }\n    });\n    ```\n\nEven multiple `Thunk` main functions with diferent scope are composed,\neach scope would be seperated from each other,\nwhich means, `onerror` and `debug` would not run in other scopes.\n\n### Thunk(start)\n\nThis is the main function, to create new `thunk` functions.\n\nThe parameter `start` could be:\n\n1. a `thunk` function, by calling this function a new `thunk` function will be returned\n\n    ```js\n    var thunk1 = Thunk(1);\n    var thunk2 = Thunk(thunk1); // thunk2 equals to thunk1;\n    ```\n\n2. `function (callback) {}`, by calling it, results woule be gathered and be passed to the next `thunk` function\n\n    ```js\n    Thunk(function (callback) {\n      callback(null, 1)\n    })(function (error, value) {\n      console.log(error, value); // null 1\n    });\n    ```\n\n3. a Promise object, results of Promise would be passed to a new `thunk` function\n\n    ```js\n    var promise = Promise.resolve(1);\n\n    Thunk(promise)(function (error, value) {\n      console.log(error, value); // null 1\n    });\n    ```\n\n4. objects which implements methods of `toThunk`\n\n    ```js\n    var then = Thenjs(1); // then.toThunk() return a thunk function\n\n    Thunk(then)(function (error, value) {\n      console.log(error, value); // null 1\n    });\n    ```\n\n5. values in other types would be valid results passing to a new `thunk` function\n\n    ```js\n    Thunk(1)(function (error, value) {\n      console.log(error, value); // null 1\n    });\n\n    Thunk([1, 2, 3])(function (error, value) {\n      console.log(error, value); // null [1, 2, 3]\n    });\n    ```\n\nYou can also run with `this`:\n\n    ```js\n    Thunk.call({x: 123}, 456)(function (error, value) {\n      console.log(error, this.x, value); // null 123 456\n      return 'thunk!';\n    })(function (error, value) {\n      console.log(error, this.x, value); // null 123 'thunk!'\n    });\n    ```\n\n### Thunk.all(obj)\n\nReturns a `thunk` function.\n\n`obj` can be an array or an object that contains any value. `Thunk.all` will transform value to a `thunk` function and excuted it in parallel. After all of them are finished, an array containing results(in its original order) would be passed to the a new `thunk` function.\n\n```js\nThunk.all([\n  Thunk(0),\n  Thunk(1),\n  2,\n  Thunk(function (callback) { callback(null, [3]); })\n])(function (error, value) {\n  console.log(error, value); // null [0, 1, 2, [3]]\n});\n\nThunk.all({\n  a: Thunk(0),\n  b: Thunk(1),\n  c: 2,\n  d: Thunk(function (callback) { callback(null, [3]); })\n})(function (error, value) {\n  console.log(error, value); // null {a: 0, b: 1, c: 2, d: [3]}\n});\n```\n\nYou may also write code like this:\n\n```js\nThunk.all.call({x: [1, 2, 3]}, [4, 5, 6])(function (error, value) {\n  console.log(error, this.x, value); // null [1, 2, 3] [4, 5, 6]\n  return 'thunk!';\n})(function (error, value) {\n  console.log(error, this.x, value); // null [1, 2, 3] 'thunk!'\n});\n```\n\n### Thunk.seq([thunk1, ..., thunkX])\n### Thunk.seq(thunk1, ..., thunkX)\n\nReturns a `thunk` function.\n\n`thunkX` can be any value, `Thunk.seq` will transform value to a `thunk` function and excuted it in order. After all of them are finished, an array containing results(in its original order) would be passed to the a new `thunk` function.\n\n```js\nThunk.seq([\n  function (callback) {\n    setTimeout(function () {\n      callback(null, 'a', 'b');\n    }, 100);\n  },\n  Thunk(function (callback) {\n    callback(null, 'c');\n  }),\n  [Thunk('d'), Thunk('e')], // thunk in array will be excuted in parallel\n  function (callback) {\n    should(flag).be.eql([true, true]);\n    flag[2] = true;\n    callback(null, 'f');\n  }\n])(function (error, value) {\n  console.log(error, value); // null [['a', 'b'], 'c', ['d', 'e'], 'f']\n});\n```\nor\n\n```js\nThunk.seq(\n  function (callback) {\n    setTimeout(function () {\n      callback(null, 'a', 'b');\n    }, 100);\n  },\n  Thunk(function (callback) {\n    callback(null, 'c');\n  }),\n  [Thunk('d'), Thunk('e')], // thunk in array will be excuted in parallel\n  function (callback) {\n    should(flag).be.eql([true, true]);\n    flag[2] = true;\n    callback(null, 'f');\n  }\n)(function (error, value) {\n  console.log(error, value); // null [['a', 'b'], 'c', ['d', 'e'], 'f']\n});\n```\n\nYou may also write code like this:\n\n```js\nThunk.seq.call({x: [1, 2, 3]}, 4, 5, 6)(function (error, value) {\n  console.log(error, this.x, value); // null [1, 2, 3] [4, 5, 6]\n  return 'thunk!';\n})(function (error, value) {\n  console.log(error, this.x, value); // null [1, 2, 3] 'thunk!'\n});\n```\n\n### Thunk.digest(error, val1, val2, ...)\n\nReturns a `thunk` function.\n\nTransform a Node.js callback function into a `thunk` function.\nThis `thunk` function retuslts in `(error, val1, val2, ...)`, which is just being passed to a new `thunk` function,\nlike:\n\n```js\nThunk(function (callback) {\n  callback(error, val1, val2, ...);\n})\n```\n\nOne use case:\n\n```js\nThunk(function (callback) {\n  //...\n  callback(error, result);\n})(function (error, value) {\n  //...\n  return Thunk.digest(error, value);\n})(function (error, value) {\n  //...\n});\n```\n\nYou may also write code with `this`：\n\n```js\nvar a = {x: 1};\nThunk.digest.call(a, null, 1, 2)(function (error, value1, value2) {\n  console.log(this, error, value1, value2) // { x: 1 } null 1 2\n});\n```\n\n### Thunk.thunkify(fn)\n\nReturns a new function that would return a `thunk` function\n\nTransform a `fn` function which is in Node.js style into a new function.\nThis new function does not accept `callback` as arguments, but accepts `thunk` functions.\n\n```js\nvar Thunk = require('../thunks.js')();\nvar fs = require('fs');\nvar fsStat = Thunk.thunkify(fs.stat);\n\nfsStat('thunks.js')(function (error, result) {\n  console.log('thunks.js: ', result);\n});\nfsStat('.gitignore')(function (error, result) {\n  console.log('.gitignore: ', result);\n});\n```\n\nYou may also write code with `this`:\n\n```js\nvar obj = {a: 8};\nfunction run(x, callback) {\n  //...\n  callback(null, this.a * x);\n};\n\nvar run = Thunk.thunkify.call(obj, run);\n\nrun(1)(function (error, result) {\n  console.log('run 1: ', result);\n});\nrun(2)(function (error, result) {\n  console.log('run 2: ', result);\n});\n```\n\n### Thunk.delay(delay)\n\nReturn a `thunk` function, this `thunk` function will be called after `delay` milliseconds.\n\n```js\nconsole.log('Thunk.delay 500: ', Date.now());\nThunk.delay(500)(function () {\n  console.log('Thunk.delay 1000: ', Date.now());\n  return Thunk.delay(1000);\n})(function () {\n  console.log('Thunk.delay end: ', Date.now());\n});\n```\n\nYou may also write code with `this`:\n\n```js\nconsole.log('Thunk.delay start: ', Date.now());\nThunk.delay.call(this, 1000)(function () {\n  console.log('Thunk.delay end: ', Date.now());\n});\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/thunks/thunks/issues"
  },
  "_id": "thunks@1.5.3",
  "_shasum": "5bab8923edf22caaa964b2cc21e464037fec920d",
  "_from": "thunks@^1.3.0",
  "_resolved": "https://registry.npmjs.org/thunks/-/thunks-1.5.3.tgz"
}
